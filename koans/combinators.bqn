# Copyright 2022 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.

âŸ¨TestSuiteâŸ© â† â€¢Import "../test.bqn"

ts â† TestSuite "Combinators"


# We recently learned about using âˆ˜ (Atop) for creating new functions.
# âˆ˜ is known as a combinator, which is a type of higher-order function.
# Ë™ (Constant) is another combinator.  Combinators can be used exclusively to create
# programs in what is called tacit programming, or point-free style.
# Instead of using if-statements, for-loops, and other control constructs,
# combinators can be used to build complex functionality.
# Because they don't specify arguments explicitly, combinators lend
# themselves to very concise programs.
#
# Ëœ (Self) is another combinator.  When applied to a diadic function to
# which a single argument is supplied, it supplies that argument on
# both sides.  That is, ğ”½Ëœ ğ•© is equivalent to ğ•© ğ”½ ğ•©.

{ ğ•¤ â‹„ âˆ = +Ëœ 2 } ts._Test "Add Self"
{ ğ•¤ â‹„ âˆ = Ã—Ëœ 2 } ts._Test "Multiply Self"
{ ğ•¤ â‹„ âˆ = â‹†Ëœ 2 } ts._Test "Power Self"
{ ğ•¤ â‹„ âˆâ€¿âˆâ€¿âˆ â‰¡ +Ëœ 1â€¿2â€¿3 } ts._Test "Pervasive Self functions still pervasive"

{ ğ•¤ â‹„ âˆâ€¿âˆâ€¿âˆ â‰¡ Ã·Ëœ Â¯8â€¿123â€¿7.532 } ts._Test "Divide Self"
{ ğ•¤ â‹„ âˆâ€¿âˆâ€¿âˆ â‰¡ -Ëœ 52â€¿Â¯12â€¿0.3 } ts._Test "Subtract Self"

{ ğ•¤ â‹„ âˆ = Ã—Ëœâˆ˜(+Â´) 1â€¿2â€¿3 } ts._Test "Self on left argument of Atop"

{ ğ•¤ â‹„ âŸ¨3, 3, 3âŸ©â€¿âŸ¨2, 2âŸ©â€¿âŸ¨1âŸ© â‰¡ â¥Š 3â€¿2â€¿1
} ts._Test "Self size"


# When applied to a function which will take two arguments,
# Ëœ (Swap) swaps the arguments in question.  That is, ğ•¨ ğ”½Ëœ ğ•© is equivalent
# to ğ•© ğ”½ ğ•¨.

{ ğ•¤ â‹„ âˆ = 1 -Ëœ 2 } ts._Test "Subtract Swap"
{ ğ•¤ â‹„ âˆ = 2 Ã·Ëœ 32 } ts._Test "Divide Swap"
{ ğ•¤ â‹„
  Dim â† 2â€¿âˆ˜Ë™
  âˆ â‰¡ 1 âŠ 1â€¿2â€¿3â€¿4 â¥ŠËœ Dim 0
} ts._Test "Second half of numbers"

{ ğ•¤ â‹„ 3 = 9 âˆš 2 } ts._Test "Root swap"

# This can be useful to reduce the number of parentheses needed, at times.
# The below examples are somewhat contrived, but the same principal will
# prove useful once we cover more tacit programming.
#
# Note: add parentheses to the right side to form an equivalent expression.


{ ğ•¤ â‹„ (2 Ã·Ëœ 9 - 3) = 9 - 3 Ã· 2} ts._Test "Reduce parentheses"
{ ğ•¤ â‹„ (8â€¿27 âˆšËœ 6 - 3) â‰¡ 6 - 3 âˆš 8â€¿27 } ts._Test "Reduce more parentheses"

{ ğ•¤ â‹„
  a â† (1 + 2) âˆš 27
  # Note: rewrite the above expression without parentheses.
  a = âˆ
} ts._Test "Rearrange to reduce parentheses"

# â—‹ (Over) is a combinator similar to âˆ˜.  In the monadic case, they act
# the same.  That is, ğ”½ â—‹ ğ”¾ ğ•© is equivalent to ğ”½ âˆ˜ ğ”¾ ğ•© which is equivalent
# to ğ”½ (ğ”¾ ğ•©).  In the diadic case, âˆ˜ passes both arguments to ğ”¾, and then
# passes the result to ğ”½.  â—‹, though, passes each argument, separately, to
# a monadic ğ”¾, then passes the results to a diadic ğ”½.  That is,
# ğ•¨ ğ”½ â—‹ ğ”¾ ğ•© is equivalent to (ğ”¾ ğ•¨) ğ”½ (ğ”¾ ğ•©).  Shown graphically,
#
#     ğ”½ â—‹ ğ”¾ ğ•©      ğ•¨ ğ”½ â—‹ ğ”¾ ğ•©
#
#       ğ”½              ğ”½
#       â”‚             â•± â•²
#       ğ”¾            ğ”¾   ğ”¾
#       â”‚            â”‚   â”‚
#       ğ•©            ğ•¨   ğ•©
#
# You may notice that both âˆ˜ and â—‹ are circles.  All 2-modifiers contain
# a circle in their symbols, similar to how all 1-modifiers are superscript.

{ ğ•¤ â‹„ âˆ = 2 - â—‹ (Ã—Ëœ) 3 } ts._Test "Difference of squares"
{ ğ•¤ â‹„ âˆ = -Â´ â—‹ (Ã—Ëœ) 2â€¿3 } ts._Test "Another difference of squares"

{ ğ•¤ â‹„
  LongerThan â† >â—‹â‰ 
  âˆâ€¿âˆâ€¿âˆ â‰¡ âŸ¨
    "shape" LongerThan "rank"
    "dyadic" LongerThan "monadic"
    "apl" LongerThan "bqn"
  âŸ©
} ts._Test "Comparing string length"

{
  # Note: The tables' contents should remain unchanged.
  table1 â† â†‘â€¿2â€¿3 â¥Š 1â€¿2â€¿3â€¿4â€¿5â€¿6â€¿7â€¿8â€¿9
  table2 â† â†‘â€¿1â€¿6 â¥Š 1â€¿2â€¿3â€¿4â€¿5â€¿6â€¿7â€¿8â€¿9
  table1 â‰¢â—‹(â¥ŠË˜) table2
} ts._Test "Comparing table contents"

{ ğ•¤ â‹„
  AbsoluteValue â† âˆšâˆ˜Ã—Ëœ
  EquivalentMagnitude â† â‰¡ # Hint: update this function
  9â€¿2â€¿3 EquivalentMagnitude Â¯9â€¿2â€¿Â¯3
} ts._Test "Checking magnitude"

{ ğ•¤ â‹„
  array1 â† 1â€¿3 â¥Š 1â€¿2
  array2 â† 3â€¿1 â¥Š 1â€¿2
  âˆ â‰¡ array1 +â—‹â¥Š array2
} ts._Test "Adding dissimilar shaped arrays"

{ ğ•¤ â‹„
  xs â† 0â€¿1
  ys â† 0â€¿3

  Slope â† Ã·â—‹(-Â´)Ëœ
  âˆ â‰¡ xs Slope ys
} ts._Test "Slope of the line"


ts.Report @
