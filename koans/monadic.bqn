# Copyright 2022 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.

âŸ¨TestSuiteâŸ© â† â€¢Import "../test.bqn"

ts â† TestSuite "Monadic Functions"


# A function in BQN can either take one argument or two. If it takes
# one argument, it is called "monadic". Otherwise, it is "diadic".
# Diadic functionsâ€”like the math functions we've seen so farâ€”are
# written as infixes.
#
# Most built-in functions are overloaded and support both arities.
# For example, when given two arguments, - is "Subtract", and gives
# the difference between the two numbers.  When given a single argument,
# it is monadic, -, and has the name "Negate".

{ ğ•¤ â‹„ âˆ = 1 - 1} ts._Test "Subtract"
{ ğ•¤ â‹„ âˆ = - 1} ts._Test "Negate"


# When a function does not have a left argument, it is evaluated as monadic.
# This can occur when a monadic function is in an expression by itself,
# or when adjacent to other functions.

{ ğ•¤ â‹„ âˆ = - 2 } ts._Test "Monadic expression"
{ ğ•¤ â‹„ âˆ = 1 + - 1 } ts._Test "Adjacent functions"


# Monadic Ã— (Sign) gives the sign of its argument, Â¯1 if negative,
# 0 if zero, and 1 if positive.

{ ğ•¤ â‹„ âˆ = Ã— Â¯8 } ts._Test "Sign of a negative number"
{ ğ•¤ â‹„ âˆ = Ã— 8 } ts._Test "Sign of a positive number"
{ ğ•¤ â‹„ âˆ = Ã— 0 } ts._Test "Sign of zero"


# Monadic â‹† (Exponential) gives Euler's number, e, raised to the given power,
# which is approximately 2.71828.

{ ğ•¤ â‹„ âˆ = â‹† 0 } ts._Test "Any number raised to zero"
{ ğ•¤ â‹„ 2.719 > â‹† âˆ } ts._Test "Approximating Euler's constant from above"
{ ğ•¤ â‹„ 2.717 < â‹† 0 } ts._Test "Approximating Euler's constant from below"


# Monadic Ã· (Reciprocal) gives the reciprocal of the argument.  That is,
# given ğ•©, it returns 1 Ã· ğ•©.

{ ğ•¤ â‹„ âˆ = Ã· 2 } ts._Test "Reciprocal of two"
{ ğ•¤ â‹„ 0.1 = Ã· âˆ } ts._Test "One tenth"
{ ğ•¤ â‹„ âˆ = Ã· âˆ } ts._Test "Reciprocal of âˆ"
{ ğ•¤ â‹„ âˆ = Ã· Ã· 4 } ts._Test "Ã· is its own inverse"
{ ğ•¤ â‹„ âˆ = Ã· âˆ } ts._Test "The inverse of a really big number is really small"
{ ğ•¤ â‹„ 0 = Ã· 0 } ts._Test "The inverse of a really small number is really big"


# Monadic âˆš (Square root) gives the square root of its argument.

{ ğ•¤ â‹„ âˆ = âˆš 4 } ts._Test "Square root of 4"
{ ğ•¤ â‹„ âˆ = âˆš 9 } ts._Test "Square root of 9"
{ ğ•¤ â‹„ (âˆš âˆ) = 213 â‹† Ã· 2 } ts._Test "Square root equivalence"


# TODO: Monadic + (Conjugate) gives the complex conjugate.  However, no BQN
# implementations currently support complex numbers.


ts.Report @
