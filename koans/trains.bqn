# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.

âŸ¨TestSuiteâŸ© â† â€¢Import "../test.bqn"

ts â† TestSuite "Trains"


# Combinators are one means of combining old functions to create a new one;
# trains are another. A train consists of monadic or dyadic functions written
# side-by-side. A 3-train is a string of three functions. Take for example ğ”½ +
# ğ”¾. If called with a single argument, then the function (ğ”½ + ğ”¾) ğ•© is
# equivalent to (ğ”½ ğ•©) + ğ”¾ ğ•©. If called with two arguments, then ğ•¨ (ğ”½ + ğ”¾) ğ•© is
# equivalent to (ğ•¨ ğ”½ ğ•©) + (ğ•¨ ğ”¾ ğ•©). Visually,
#
#     ğ”½ + ğ”¾ ğ•©      ğ•¨ ğ”½ + ğ”¾ ğ•©
#
#       +              +
#      â•± â•²            â•± â•²
#     ğ”½   ğ”¾          ğ”½   ğ”¾
#     â”‚   â”‚         â•±â•²   â•±â•²
#     ğ•©   ğ•©        ğ•¨  ğ•© ğ•¨  ğ•©

{ ğ•¤ â‹„
  âˆ = 3 (- Ã· +) 1
} ts._Test "Simple train"

{ ğ•¤ â‹„
  Mean â† +Â´ Ã— â‰ 
  2 = Mean 1â€¿2â€¿3
} ts._Test "Mean"

{ ğ•¤ â‹„
  Id â† - -
  Proportion â† Id Ã· +Â´â—‹â¥Š
  âˆ â‰¡ Proportion 5â€¿2â€¿3
} ts._Test "Get the proportion of each number in a list"


# The function â‹ˆ (Pair) joins two values into a list. It can be useful as a central
# function for comparing the results of functions.

{ ğ•¤ â‹„
  âˆ â‰¡ 2 (+ â‹ˆ -) 3
} ts._Test "Comparing + and -"

{ ğ•¤ â‹„
  âˆ â‰¡ (+Â´ â‹ˆ -Â´) 1â€¿2â€¿3
} ts._Test "Comparing +Â´ and -Â´"

{ ğ•¤ â‹„
  âˆ â‰¡ 9 (â‹ˆâ—‹âˆš) 4
} ts._Test "Comparing square roots"


# The left argument in trains can be replaced by Â· (Nothing).  In this case,
# the expression is equivalent to composition.  That is, Â·ğ”½ğ”¾ is equivalent to
# ğ”½ âˆ˜ ğ”¾.

{ ğ•¤ â‹„
  Id â† - -
  AbsoluteValue â† âˆš âˆ˜ (Id â‹† 2Ë™)
  Distance â† Â· AbsoluteValue -
  âˆ = Â¯1 Distance 5
} ts._Test "Distance between values"

{ ğ•¤ â‹„
  F â† (Â·-+)(Â·-+)(Â·-+)
  âˆ = 3 F 2
} ts._Test "Plus minus"


# You can also just leave out the left argument, in which case it's equivalent
# to replacing it with Â·.

{ ğ•¤ â‹„
  AddNegated â† +Ë -
  âˆ â‰¡ AddNegated 2â€¿âˆ˜ â¥Š 1â€¿6â€¿Â¯3â€¿4
} ts._Test "Add negated major cells"

{ ğ•¤ â‹„
  Id â† (--) (Ã·Ã·)
  âˆ = Id 8
} ts._Test "Identities"

{ ğ•¤ â‹„
  F â† ((Ã·Ã·)+) â‹ˆ (Ã·(Ã·+))
  âˆâ€¿âˆ â‰¡ 3 F 2
} ts._Test "Equivalent composition"


# Trains can be composed. Like function application, trains associate from
# right to left. The first three functions, then, form a train which we can treat
# as a single function. If we add a function to the left of it, it's as if we have a
# two-train. That is, ğ”½ ğ”¾ ğ”½ ğ”¾ is equivalent to F (ğ”¾ F ğ”¾).  Put graphically,
#
#    (ğ”½ ğ”¾ ğ”½ ğ”¾) ğ•©   ğ•¨ (ğ”½ ğ”¾ ğ”½ ğ”¾) ğ•©
#
#        ğ”½              ğ”½
#        â”‚              â”‚
#        ğ”½              ğ”½
#       â•± â•²            â•± â•²
#      ğ”¾   ğ”¾          ğ”¾   ğ”¾
#      â”‚   â”‚         â•±â•²   â•±â•²
#      ğ•©   ğ•©        ğ•¨  ğ•© ğ•¨  ğ•©


{ ğ•¤ â‹„
  âˆ = (âˆš - Ã— -) 2
} ts._Test "Monadic 4-train"

{ ğ•¤ â‹„
  âˆ = 1 (- + Ã· Ã—) 2
} ts._Test "Dyadic 4-train"


# Similarly, if we have five functions in a row, the first three are treated
# as a single function.  So, ğ”½ ğ”¾ ğ”½ ğ”¾ ğ”½ is equivalent to ğ”½ ğ”¾ (ğ”½ ğ”¾ ğ”½).  Graphically,
#
#  (ğ”½ ğ”¾ ğ”½ ğ”¾ ğ”½) ğ•©    ğ•¨ (ğ”½ ğ”¾ ğ”½ ğ”¾ ğ”½) ğ•©
#
#      ğ”¾                   ğ”¾
#     â•± â•²                 â•± â•²
#    ğ”½   ğ”¾               ğ”½   ğ”¾
#    â”‚  â•± â•²             â•±â•²   â•±â•²
#    ğ•© ğ”½   ğ”½           ğ•¨  ğ•© ğ”½  ğ”½
#      â”‚   â”‚               â•±â•²  â•±â•²
#      ğ•©   ğ•©              ğ•¨  ğ•©ğ•¨  ğ•©

{ ğ•¤ â‹„
  âˆ = (-Â´ Ã— +Â´ Ã— -Â´) 1â€¿2â€¿3
} ts._Test "Monadic 5-train"

{ ğ•¤ â‹„
  âˆ = 2 (â‹† Ã· Ã— - +) 3
} ts._Test "Diadic 5-train"


# You may have noticed that the left-most form is 2-train when the number of
# functions is even, and a 3-train when the number of functions is odd. For
# the below, consider whether Left could be inserted as the first function in
# the sequence.

{ ğ•¤ â‹„
  Id â† { ğ•© }
  Left â† { ğ•¨ }
  (Id Left Id Left Id Left Id) 0
} ts._Test "A long train"


# Function application shares the lowest precedence level with assignment.
# Once all other parts of an expression are evaluated, the expression can be
# either a function expression or a subject expression. It is a subject
# expression if the rightmost element is a subject, otherwise it is a function
# expression. This means that expressions with subjects _not_ at the rightmost
# expression are function expressions. How is this so? The subjects, in these
# cases, are treated as having an implicit Ë™. That is, ğ•© ğ”½ ğ”¾ is equivalent to
# ğ•©Ë™ ğ”½ ğ”¾.

{ ğ•¤ â‹„
  # We can tell that it is a function expression immediately, because it doesn't
  # fail when assigned to a variable with a function role.
  F â† 1 + -
  (1Ë™ + -) â‰  F 3
} ts._Test "Equivalence of left subject with constant"

{ ğ•¤ â‹„
  DoubleFlatten â† 2 Ã— â¥Š
  âˆ â‰¡ DoubleFlatten 2â€¿2 â¥Š 1â€¿2
} ts._Test "Double a flattened array"

{ ğ•¤ â‹„
  Decrement â† 1 -Ëœ â¥Š
  âˆ â‰¡ Decrement 1â€¿2â€¿3
} ts._Test "Decrement"


ts.Report @
