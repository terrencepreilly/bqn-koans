# Copyright 2022 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.

‚ü®TestSuite‚ü© ‚Üê ‚Ä¢Import "../test.bqn"

ts ‚Üê TestSuite "Arrays"


# BQN is an array language, which means that the basic data structure of BQN is
# the array.  All values in BQN are either scalars or arrays. Examples of scalar
# values include numbers such as 1, or 3.1415, characters such as 'a' or '‚çã'.
# Scalar values are single values and have no shape.  Arrays, on the other hand,
# have a shape.  The lists we have been dealing with so far are an example of an
# array.
#
# BQN displays arrays differently depending on the shape. An array of shape
# ‚ü®‚ü© can be constructed using < (Enclose).  For example, < 0 is displayed
#
#    ‚îå¬∑
#    ¬∑ 0
#        ‚îò
#
# An array of shape ‚ü® 4 ‚ü© (a list), is displayed
#
#    ‚ü® 0 1 2 3 ‚ü©
#
# An array of size ‚ü® 2 2 ‚ü© is displayed
#
#     ‚îå‚îÄ
#     ‚ïµ 0 1
#       2 3
#           ‚îò
#
# (Similar to the unit array, but with no dots.)  Arrays of higher order
# are displayed by separating by spaces.
#
#     ‚îå‚îÄ
#     ‚ïé 0 1
#       2 3
#
#       4 5
#       6 7
#           ‚îò


# The shape of an array can be found using the monad ‚â¢ (Shape).
# ‚â¢ returns a list of numbers representing the size of each dimension
# of an array.  Since they have no shape, ‚â¢ returns an empty list for
# scalars.  Each item in the returned array is an "axis" of the array.

{ ùï§ ‚ãÑ ‚àû ‚â° ‚â¢ 1 } ts._Test "Shape of a number"
{ ùï§ ‚ãÑ ‚àû ‚â° ‚â¢ ' ' } ts._Test "Shape of a character"


# Since a list has one dimension, its shape is equal to a list containing its
# length.

{ ùï§ ‚ãÑ ‚àû ‚â° ‚â¢ 1‚Äø2‚Äø3 } ts._Test "Shape of a list"
{ ùï§ ‚ãÑ ‚àû ‚â° ‚â¢ ‚ü®‚ü©  } ts._Test "Shape of an empty list"
{ ùï§ ‚ãÑ ‚àû ‚â° ‚â¢ ‚ü®1‚Äø2 ‚ãÑ 3‚Äø4‚ü© } ts._Test "Shape of a nested list"


# To build arrays of higher dimensionality, we'll need some more functions.
# The diadic function, ‚•ä (Reshape), takes an array of numbers (a shape) as
# a left argument, and an array on the right.  ‚•ä reshapes the array to conform
# to the given shape.

{ ùï§ ‚ãÑ ‚àû ‚â° ‚â¢ 2‚Äø2 ‚•ä 1‚Äø2‚Äø3‚Äø4 } ts._Test "Checking a two-dimisional array's shape"
{ ùï§ ‚ãÑ ‚àû ‚â° ‚â¢ 0 ‚•ä 1‚Äø2 } ts._Test "Checking a zero-dimensional array's shape"
{ ùï§ ‚ãÑ ‚àû ‚â° ‚â¢ 1‚Äø1‚Äø1 ‚•ä 1 } ts._Test "Three dimensional array"


# Sometimes you'll have an array of elements, and you want to reshape it,
# but you only know the value of one dimension.  For example, you may have
# a list of elements representing ranges, where odd numbers are the start
# of a range, and even numbers are the end of a range.  E.g.:
#
# 18‚Äø20‚Äø1‚Äø3‚Äø10‚Äø11‚Äø5‚Äø8
#
# representing 18-20, 1-3, 10-11, 5-8.  You may want to reshape this into
# an array with two columns (say, so that you can sort it.)  You can do this
# by using the symbol ‚àò for the unknown dimension in the shape.  For example,
# we could transform the above using
#
# ‚àò‚Äø2 ‚•ä 18‚Äø20‚Äø1‚Äø3‚Äø10‚Äø11‚Äø5‚Äø8
#
# And we would get
#
#    ‚îå‚îÄ
#    ‚ïµ 18 20
#       1  3
#      10 11
#       5  8
#            ‚îò

{ ùï§ ‚ãÑ ‚àû ‚â° ‚â¢ 1‚Äø‚àò ‚•ä 1‚Äø2‚Äø3‚Äø4‚Äø5‚Äø6 } ts._Test "Reshaping to a single row"
{ ùï§ ‚ãÑ ‚àû ‚â° ‚â¢ ‚àò‚Äø3 ‚•ä 1‚Äø2‚Äø3‚Äø4‚Äø5‚Äø6 } ts._Test "Reshaping to a three-column table"


# If an array is too small for the shape it's given, ‚•ä will reuse
# the elements of the array, cyclically.

{ ùï§ ‚ãÑ ‚àû ‚â° ‚ü®4‚ü© ‚•ä 1‚Äø2‚Äø3 } ts._Test "Recycling numbers"
{ ùï§ ‚ãÑ ‚àû ‚â° ‚ü®4‚ü© ‚•ä "abc" } ts._Test "Recycling characters"
{ ùï§ ‚ãÑ ‚àû ‚â° ‚ü®6‚ü© ‚•ä 1‚Äø2‚Äø3 } ts._Test "Recycling an entire list"
{ ùï§ ‚ãÑ ‚àû ‚â° ‚ü®8‚ü© ‚•ä 1‚Äø2‚Äø3 } ts._Test "Reusing elements multiple times"
{ ùï§ ‚ãÑ ‚àû ‚â° ‚ü®3‚ü© ‚•ä 0 } ts._Test "Reshaping a single number"
{ ùï§ ‚ãÑ ‚àû ‚â° ‚ü®2‚ü© ‚•ä 2‚Äø2‚Äø2‚Äø2 ‚•ä 1‚Äø3 ‚•ä 6‚Äø2 ‚•ä "abc" } ts._Test "Preservation of initial values"
{ ùï§ ‚ãÑ ‚àû ‚â° ‚ü®2‚ü© ‚•ä 2‚Äø2‚Äø2‚Äø2 ‚•ä ‚ü®1‚ü© ‚•ä 6‚Äø2 ‚•ä "abc" } ts._Test "Non-preservation of initial values"


# The monadic version of ‚•ä (Deshape) creates a list containing all
# of the elements of the array.

{ ùï§ ‚ãÑ ‚àû ‚â° ‚•ä 2‚Äø3 ‚•ä "abcdef" } ts._Test "Shaping and deshaping"
{ ùï§ ‚ãÑ ‚àû = ‚â† ‚•ä 3‚Äø9 ‚•ä 0 } ts._Test "Getting number of elements from the shape"


# Besides a shape and elements, arrays have other properties.  An array's "fill
# element" is like a default element of an array.  It is used to fill in a result
# when there are insufficient elements in the original array. For example, ‚•ä
# will use the fill element of the array if the shape contains ‚Üë.  Similar to
# ‚àò, ‚Üë replaces a dimension in the shape.  The fill element of the array
# attempts to satisfy some property of the existing elements in the array.  If
# the elements are all numbers, the fill should be 0.  If the elements are all
# characters, the fill should be ' '. For details of how the fill element is
# calculated, see https://mlochbaum.github.io/BQN/doc/fill.html.

{ ùï§ ‚ãÑ ‚àû ‚â° ‚•ä 2‚Äø‚Üë ‚•ä 1‚Äø2‚Äø3 } ts._Test "Filling an array of numbers"
{ ùï§ ‚ãÑ ‚àû ‚â° ‚•ä 2‚Äø‚Üë ‚•ä "abc" } ts._Test "Filling an array of characters"


# So far, when discussing the values that make up an array, we've been discussing
# elements.  Elements are the smallest component values of an array: values like
# 1 or 'z'.  An array with no elements is empty.  The 1-modifier, ¬®, applies the
# function to every element in the array.

{ ùï§ ‚ãÑ ‚àû = ‚â† ‚•ä 2‚Äø3‚Äø2 ‚•ä 1‚Äø2‚Äø3 } ts._Test "Get # of elements in the array"

# HINT: Add a 1-modifier to finish the expressions
{ ùï§ ‚ãÑ (3‚Äø1 ‚•ä 1) ‚â° 1Àô 3‚Äø‚Üë ‚•ä 1‚Äø2 } ts._Test "Modifying elements in the array"
{ ùï§ ‚ãÑ 9 ‚â° √ó ‚â¢ 3‚Äø1‚Äø3 ‚•ä 'a' } ts._Test "Another way to get # of elements"


# Cells are another way of describing the contents of an array. Cells are
# subarrays of the array.  The major cells of an array are the subarrays
# at each index along the first axis of an array.  The major cell of an
# array has one fewer axis than the original array.  For example, if we have
# an array, 2‚Äø2 ‚•ä "abcd", which looks like
#
#    ‚îå‚îÄ
#    ‚ïµ"ab
#      cd"
#         ‚îò
#
# Then the first major cell of 2‚Äø2 ‚•ä "abcd" has the shape ‚ü®2‚ü©, which is
# the list: "ab".

# To extract the major cell of an array, we can use the function ‚äè (Select).  ‚äè
# takes an index on the left, and the array on the right.

{ ùï§ ‚ãÑ ‚àû ‚â° 0 ‚äè 2‚Äø2 ‚•ä "abcd" } ts._Test "Get first major cell"
{ ùï§ ‚ãÑ ‚àû ‚â° 1 ‚äè 2‚Äø2 ‚•ä "abcd" } ts._Test "Get second major cell"


# The 1-modifier ¬¥, which we saw earlier, inserts the given function between
# the elements of its argument.  Similarly, Àù (Insert) inserts the given function
# between the major cells of its argument.

{ ùï§ ‚ãÑ ‚àû ‚â° +Àù 2‚Äø2 ‚•ä 1‚Äø2‚Äø3‚Äø4 } ts._Test "Summing columns"
{ ùï§ ‚ãÑ
  (+¬¥ ‚ü®3‚ü© ‚•ä ‚ü®1‚ü©) ‚â° +Àù 3‚Äø3 ‚•ä 1‚Äø2‚Äø3
} ts._Test "Adding lists vs summing columns"

{ ùï§ ‚ãÑ ‚àû = +¬¥ ‚ü®3‚ü© ‚•ä 1 } ts._Test "Summing over a list"
{ ùï§ ‚ãÑ ‚àû = +¬¥ +Àù 3‚Äø3 ‚•ä 1 } ts._Test "Summing over summed columns"
{ ùï§ ‚ãÑ
  ‚àû = +¬¥ +Àù +Àù 3‚Äø3‚Äø3 ‚•ä 1
} ts._Test "Sum over summed columns of summed tables"


# The 1-modifier ¬® applies the function to the elements of the array.
# Likewise, the 1-modifier Àò (Cells) applies the function to the major cells
# of the array.

{ ùï§ ‚ãÑ ‚àû ‚â° ‚â†Àò 2‚Äø3 ‚•ä 1 } ts._Test "Length of major cells"

{ ùï§ ‚ãÑ
  ‚àû ‚â° +¬¥Àò 2‚Äø3 ‚•ä 1‚Äø1‚Äø1‚Äø2‚Äø2‚Äø2
} ts._Test "Sum the rows of an array"

{ ùï§ ‚ãÑ
  (2‚Äø2 ‚•ä ‚ü®1‚ü©) ‚â° ‚äèÀò 2‚Äø2‚Äø2 ‚•ä 1‚Äø2‚Äø3‚Äø4
} ts._Test "Take the first major cell of each major cell"


ts.Report @
