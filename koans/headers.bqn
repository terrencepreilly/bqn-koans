# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.

âŸ¨TestSuiteâŸ© â† â€¢Import "../test.bqn"

ts â† TestSuite "Headers"


# When a block becomes more complex, it can be more difficult to tell what the
# type of the function is. Headers are a means of communicating the type of a
# function block, and are separated from the block definition by a colon.
# Monadic functions can be documented like { ğ•Š ğ•© : ... }.

{ ğ•¤ â‹„
  IsPositive â† { ğ•Š ğ•© : ğ•© > 0 }
  0 = IsPositive 3
} ts._Test "Defining a monadic function"


# Dyadic funcitons can be documented similarly like { ğ•¨ ğ•Š ğ•© : ... }.

{ ğ•¤ â‹„
  IsGreater â† { ğ•¨ ğ•Š ğ•© : 0 > ğ•© - ğ•¨ }
  2 IsGreater 7
} ts._Test "Defining a dyadic function"


# One modifiers use headers like { ğ•¨ _ğ•£ ğ”½ ğ•© : ... }.

{ ğ•¤ â‹„
  _Swap â† { ğ•¨ ğ”½ _ğ•£ ğ•© : ğ•© ğ”½ ğ•¨ }
  Â¯3 = 2 (- _Swap) 5
} ts._Test "Defining a one-modifier"


# Similarly, two-modifiers can be documented like { ğ•¨ ğ”½ _ğ•£_ ğ”¾ ğ•© : ... }.

{ ğ•¤ â‹„
  _Atop_ â† { ğ•¨ ğ”½ _ğ•£_ ğ”¾ ğ•© :  ğ”½ ğ•¨ ğ”¾ ğ•© }
  F â† - _Atop_ +
  âˆ = 3 F 2
} ts._Test "Defining a two-modifier"


# Multiple headers-body pairs can be specified for a block, separated by
# semicolons. The first matching header determines the body which is executed.
# The role of the function must still match the name it's assigned to, so we
# can't mix modifier and function headers.

{ ğ•¤ â‹„
  Square â† {
   ğ•Š ğ•© : ğ•© â¥ŠËœ â‹ˆËœ âˆš â‰  ğ•© ;
   ğ•¨ ğ•Š ğ•© : ğ•¨â€¿ğ•¨ â¥Š ğ•©
  }
  ({4 Square ğ•©} â‰¡ Square) 0â€¿2â€¿3â€¿5
} ts._Test "Monadic and dyadic verb in one"


# Beyond documenting the type of the block, the special symbols used in the
# header can be replaced by names to help document or distinguish them.

{ ğ•¤ â‹„
  _Compare_ â† {
    Left _ğ•£_ Right x : (Left x) â‹ˆ Right x
  }
  âˆ â‰¡ {ğ•© Ã— 2} _Compare_ {ğ•© Ã· 2} 4
} ts._Test "Documenting arguments"

{
  ğ•¤ â‹„
  âˆ = Â¯2 { Left : ğ•¨ } 6
} ts._Test "Documenting function names"


# Alternatively, unneeded symbols can be trimmed from the header as long as
# the role of the block can be disambiguated.

{ ğ•¤ â‹„
  Inc â† { ğ•Š : Â¯1 + ğ•© }
  3 = Inc 2
} ts._Test "Reducing noise"


# Parameters can also be replaced by values.  In that case, the header will
# only match when the given parameters match the values.

{ ğ•¤ â‹„
  Or â† {
    0 ğ•Š 0 : 0 ;
    1 ğ•Š 0 : 1 ;
    0 ğ•Š 1 : 1 ;
    1 ğ•Š 1 : 1
  }

  âˆ â‰¡ 0â€¿0â€¿1â€¿1 OrÂ¨ 0â€¿1â€¿0â€¿1
} ts._Test "Logical operator or"

{ ğ•¤ â‹„
  And â† {
    ğ•¨ ğ•Š ğ•© : 0
  }

  0â€¿0â€¿0â€¿1 â‰¡ 0â€¿0â€¿1â€¿1 AndÂ¨ 0â€¿1â€¿0â€¿1
} ts._Test "Logical operator and"

{ ğ•¤ â‹„
  IsEmpty â† {
    ğ•Š âŸ¨âŸ© : 1 ;
    ğ•Š ğ•© : 0
  }

  IsEmpty âŸ¨1âŸ©
} ts._Test "Matching a list"


# The values replacing parameters can also be destructured values.  That is,
# you can match against partial non-scalar values.

{ ğ•¤ â‹„
  foodColors â† âŸ¨
    "green"â€¿"lettuce"
    "red"â€¿"tomato"
    "red"â€¿"apple"
    "yellow"â€¿"banana"
    "red"â€¿"cherry"
    "blue"â€¿"blueberry"
  âŸ©
  IsRed â† {
    ğ•Š "red"â€¿food : 1 ;
    ğ•Š : 0
  }
  âˆ â‰¡ IsRedÂ¨ foodColors
} ts._Test "Matching a partial list"


# To skip matching certain values, you can either use a name (in which case, the
# value will be assigned to the name), or you can use Â· (Nothing).  The values
# which match Â· will be ignored.

{ ğ•¤ â‹„
  user â† âŸ¨ 1838 â‹„ "Georges"â€¿"Bizet"âŸ©
  IsBizet â† {
    ğ•Š âŸ¨ Â· â‹„ Â·â€¿"Buzzy" âŸ© : 1 ;
    ğ•Š : 0
  }
  IsBizet user
} ts._Test "Using nothing"

{ ğ•¤ â‹„
  IsEven â† {
    0 : 1 ;
    1 : 0 ;
    2 : 1 ;
    3 : 0 ;
    4 : 1
  }
  IsEven 3
} ts._Test "IsEven"


# Destructuring works well when matching specific values, but doesn't work for
# matching against ranges or matching against derived values. In that case, we
# can use predicates. Predicates use the format { header : predicate ? body }.
# The header can be dropped, as above.

{ ğ•¤ â‹„
  Not â† { ğ•©? 0 ; 1 }
  Not 1
} ts._Test "Logical not"

{ ğ•¤ â‹„
  ChangeLight â† {
    ğ•Š "red" : "green" ;
    ğ•Š "yellow" : "red" ;
    ğ•Š "green" : "yellow"
  }

  light â† "green"
  âˆ â‰¡ ChangeLight ChangeLight ChangeLight "green"
} ts._Test "State machines"

{ ğ•¤ â‹„

  ToDoInit â† âŸ¨âŸ©Ë™
  ToDoAdd â† {  timeâ€¿description ğ•Š todoList :
    âŸ¨0, time, descriptionâŸ©â€¿todoList
  }
  ToDoNext â† {
    ğ•Š âŸ¨0, Â·, descriptionâŸ©â€¿Â· : description ;
    ğ•Š âŸ¨1, Â·, Â·âŸ©â€¿others : others ;
    ğ•Š âŸ¨âŸ© : ""
  }

  todoList â† 800â€¿"Pay Bills" ToDoAdd 930â€¿"Relax" ToDoAdd 1100â€¿"Walk dog" ToDoAdd ToDoInit âŸ¨âŸ©

  âˆ â‰¡ ToDoNext todoList
} ts._Test "ToDo lists"

ts.Report @
