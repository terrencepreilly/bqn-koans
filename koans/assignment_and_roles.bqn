# Copyright 2022 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.

âŸ¨TestSuiteâŸ© â† â€¢Import "../test.bqn"

ts â† TestSuite "Assignment"


# Typing the same values over and over again can be tiring.  To make things
# easier, we can store values in variables using â†.  Before we can use â†, we
# should know something about types and roles.   A type describes a category of
# values.  The fundamental types in BQN are numbers, characters, arrays,
# functions, 1-modifiers, 2-modifiers, and namespaces.  The role of the value
# describes how that value will be used.  When we store a value using â†, the
# name we use should reflect the role.  When a value is used as a subject role,
# the first letter should be lowercase, and should not start with a '_'. The
# number, character, and array types have the subject role by default.

{ ğ•¤ â‹„
  p â† 1â€¿2â€¿3
  âˆ = +Â´ p
} ts._Test "Simple variable substitution"

{ ğ•¤ â‹„
  a â† 1â€¿2â€¿3â€¿4
  b â† 2
  âˆ = +Â´ b Ã— a
} ts._Test "Multiple variables"

{ ğ•¤ â‹„
  shape â† â†‘â€¿2
  data â† 1â€¿2â€¿3â€¿4â€¿5â€¿6â€¿7
  âˆ â‰¡ +Ë shape â¥Š data
} ts._Test "Add odd and even numbers"


# If a value is going to be used as a function (the function role), its name
# should begin with a capital letter, and should not start or with a '_'.
# Variable names are case insensitive, which is used in BQN to mix roles.  For
# example, we may want to use the number 2 as a function, which is equivalent to
# 2Ë™ (a constant function.)
#
# The role of a variable is a syntactic property which is enforced by the
# interpreter.  To see how this works in practice, change the lowercase 'm' below
# to an uppercase 'M' and run the script to see the error message produced. Then
# change the uppercase 'M' to a lowercase letter.  In each case, you can see that
# the interpreter recognizes how a value is being used, and enforces the spelling
# convention for that particular role.

{ ğ•¤ â‹„ m â† 3 â‹„ M 5 }

{ ğ•¤ â‹„
  a â† 2
  âˆ = A 3
} ts._Test "Number value with function role"

{ ğ•¤ â‹„
  caseInsensitive â† "insensitive"
  âˆ â‰¡ Caseinsensitive 3
} ts._Test "Array value with function role"


# Since functions are values, we can also assign them to variables.  They have
# the function role by default. At the moment, it is not particularly useful, as
# we the only way we have created new functions is by apply modifiers to the
# built-in functions.  Soon, though, we'll see how to define functions more
# generally.

{ ğ•¤ â‹„
  Frobinate â† Ã·
  âˆ = 4 Frobinate 2
} ts._Test "Function with a function role"

{
  Deshape â† â¥Š
  âˆ â‰¡ Deshape â†‘â€¿4 â¥Š 1â€¿2â€¿3
} ts._Test "Deshaping"

{ ğ•¤ â‹„
  SumOver â† +Â´
  âˆ = SumOver 1â€¿2â€¿3
} ts._Test "Using function names as documentation"

{ ğ•¤ â‹„
  DivideOverRows â† Ã·Â´Ë˜
  âˆ â‰¡ â†‘â€¿2 â¥Š 10â€¿5â€¿4â€¿2
} ts._Test "Divide over each row"


# One-modifier values have a 1-modifier role by default.  This role follows
# the convention of begining with an '_'. (But it should not end with a '_'.)

{ ğ•¤ â‹„
  _Each â† Â¨
  âˆ â‰¡ 0Ë™ _Each 1â€¿2â€¿3
} ts._Test "Each with 1-modifier role"

{ ğ•¤ â‹„
  _Fold â† Â´
  âˆ â‰¡ Ã— _Fold 1â€¿2â€¿3
} ts._Test "Fold with 1-modifier role"

{ ğ•¤ â‹„
  _Insert â† Ë
  âˆ â‰¡ Ã· _Insert 2â€¿3 â¥Š 15â€¿10â€¿5â€¿3â€¿2â€¿1
} ts._Test "Insert with 1-modifier role"


# Two-modifier values have a 2-modifier role by default. We haven't yet seen a
# 2-modifier. They're similar to 1-modifiersâ€”which take a value and return a
# functionâ€”but 2-modifiers take two values (a left and right argument), and
# return a function.
#
# âˆ˜ (Atop) is a 2-modifier which is modeled after mathematical composition.
# The function ğ”½ âˆ˜ ğ”¾ is a function which first applies ğ”¾ to its arguments,
# then applies ğ”½ to the results of those arguments.  That is, ğ”½ âˆ˜ ğ”¾ ğ•© is equivalent
# to ğ”½ (ğ”¾ x), and ğ•¨ ğ”½ âˆ˜ ğ”¾ ğ•© is equivalent to ğ”½ (ğ•¨ ğ”¾ ğ•©).  Graphically, it can
# be depicted
#
#     ğ”½ âˆ˜ ğ”¾ ğ•©      ğ•¨ ğ”½ âˆ˜ ğ”¾ ğ•©
#
#       ğ”½              ğ”½
#       â”‚              â”‚
#       ğ”¾              ğ”¾
#       â”‚             â•± â•²
#       ğ•©            ğ•¨   ğ•©
#
# First, we'll see how to use âˆ˜, then we'll assign it to a variable to see how
# that role is communciated.

{ ğ•¤ â‹„
  âˆ = Ã· âˆ˜ âˆš 4
} ts._Test "Using a 1-modifier"

{ ğ•¤ â‹„
  ReciprocalSum â† Ã· âˆ˜ (+Â´)
  âŸ¨0.5, âˆ, âˆâŸ© â‰¡ ReciprocalSumÂ¨ âŸ¨
    1â€¿1
    1â€¿1â€¿2
    1â€¿2â€¿3â€¿4
  âŸ©
} ts._Test "ReciprocalSum"

{ ğ•¤ â‹„
  Tens â† 10Ë™ Ã— âŠ
  âˆ = +Â´ Tens 1â€¿3 â¥Š 1â€¿2â€¿3
} ts._Test "Ten times the first major cell"


# The spelling convention for a 2-modifier is for it to begin and end with a '_'.

{ ğ•¤ â‹„
  _Atop_ â† âˆ˜
  âˆ = âˆš _Atop_ - Â¯9
} ts._Test "2-modifier with 2-modifier role"


ts.Report @
