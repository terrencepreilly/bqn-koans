# Copyright 2022 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.

âŸ¨TestSuiteâŸ© â† â€¢Import "../test.bqn"

ts â† TestSuite "Modifiers"


# The functions we've seen so far take a value and return a value. BQN also
# supports higher-order functions, which return a function. One of the simplest
# of these is Ë™ (Constant), which takes a value and returns a function whose
# result is always that value.

{ ğ•¤ â‹„ âˆ = 0Ë™ "any value" } ts._Test "Numeric constant"
{ ğ•¤ â‹„ âˆ â‰¡ "No"Ë™ âˆ } ts._Test "String constant"
{ ğ•¤ â‹„ âˆ â‰¡ âŸ¨âŸ©Ë™ âˆ } ts._Test "List constant"
{ ğ•¤ â‹„ âˆ = ' 'Ë™ 1â€¿2â€¿3â€¿4 } ts._Test "Application to a list."


# Another simple modifier is Â¨ (Each).  Â¨ takes a function and returns a
# function which applies to each element in an array.  So, for example,
#
#    (ğ•—Â¨ ğ•©1â€¿ğ•©2â€¿...â€¿ğ•©n) â‰¡ (ğ•— ğ•©1)â€¿(ğ•— ğ•©2)â€¿...â€¿(ğ•— ğ•©n)
#
# You may have noticed that both modifiers are superscript symbols.  All built-in
# modifiers are symbols above superscripts, which makes them easy to distinguish
# from other types of functions.

{ ğ•¤ â‹„ 2â€¿âˆâ€¿âˆ â‰¡ â‰ Â¨ âŸ¨1â€¿2, 1â€¿2â€¿3, 1â€¿2â€¿3â€¿4âŸ© } ts._Test "Get lengths"
{ ğ•¤ â‹„ 1â€¿âˆ â‰¡ â‰ Â¨ âŸ¨1âŸ©â€¿âŸ¨1, 2âŸ© } ts._Test "Applying length to each"
{ ğ•¤ â‹„ 2â€¿âˆ â‰¡ â‰ Â¨ âŸ¨âŸ¨1âŸ©, âŸ¨1, 2âŸ©âŸ©â€¿âŸ¨1âŸ© } ts._Test "Applying length again"


# We said previously that normal functions are evaluated from
# right to left.  We could represent this as a tree, so that
# ğ”½1 ğ”½2 ğ”½3 ğ•© could be represented
#
#    ğ”½1
#      \
#       ğ”½2
#        \
#         ğ”½3
#           \
#            ğ•©
#
# ğ”½3 must be evaluated before ğ”½2, in order to pass a value for ğ”½2's right
# argument. This is # right-associativity.  Equivalently, representing order
# with parentheses, we could say that the expression ğ”½1 ğ”½2 ğ”½3 ğ•© is
# equivalent to ğ”½1 (ğ”½2 (ğ”½3 ğ•©)).
#
# Modifiers, however, associate to the left.  If _ğ”½1, _ğ”½2, & ğ”½3. are modifiers,
# and ğ”¾ is a function, then we could represent ğ”¾ _ğ”½1 _ğ”½2 ğ”½3 as
# ((ğ”¾ _ğ”½1) _ğ”½2) _ğ”½3.  Or, as a tree,
#
#         _ğ”½3
#        /
#       _ğ”½2
#      /
#     _ğ”½1
#    /
#   ğ”¾

{ ğ•¤ â‹„ âˆ â‰¡ 1Ë™Â¨ 2â€¿4 } ts._Test "Combining modifiers"


# Take another example, with Â¨.  Â¨ can be repeated to reach deeper into lists.
# Essentially, â‰ Â¨Â¨ is equivalent to (â‰ Â¨)Â¨.  That is, â‰ Â¨Â¨ applies â‰ Â¨ to each of
# the elements of the list.

{ ğ•¤ â‹„ âˆ = â‰  âŸ¨âŸ© } ts._Test "Normal list length"
{ ğ•¤ â‹„ âˆ â‰¡ â‰ Â¨ âŸ¨âŸ¨âŸ©, âŸ¨1âŸ©âŸ©} ts._Test "Length at depth 1"
{ ğ•¤ â‹„ âˆ â‰¡ â‰ Â¨Â¨ âŸ¨âŸ¨âŸ¨âŸ©, âŸ¨1âŸ©âŸ©, âŸ¨âŸ¨1âŸ©, âŸ¨âŸ©âŸ©âŸ©} ts._Test "Length at depth 2"
{ ğ•¤ â‹„ âˆ â‰¡ â‰ Â¨Â¨Â¨ âŸ¨âŸ¨âŸ¨âŸ¨âŸ©, âŸ¨1âŸ©âŸ©, âŸ¨âŸ¨1âŸ©, âŸ¨âŸ©âŸ©âŸ©, âŸ¨âŸ¨âŸ¨âŸ©âŸ©âŸ©âŸ© } ts._Test "Length at depth 3"


# Another useful modifier is Â´ (Fold). Â´ applies its argument between the
# elements of a list.  That is, ğ”½Â´ ğ•©1â€¿ğ•©2â€¿ğ•©3â€¿...â€¿ğ•©n is equivalent to
# ğ•©1 ğ”½ ğ•©2 ğ”½ ğ•©3 ğ”½ ... ğ”½ ğ•©n.

{ ğ•¤ â‹„ âˆ = =Â´ 0â€¿0â€¿1â€¿0â€¿1 } ts._Test "Check if all elements are equal"
{ ğ•¤ â‹„ âˆ = Ã·Â´ 4â€¿4â€¿4â€¿4â€¿4â€¿4â€¿2 } ts._Test "Repeated division"


# Â´ generalizes a common pattern in many Mathematical expressions, called
# iterated binary operations. Typically these are written as large Greek letters,
# or large versions of the operations.  Summing over a list, for example, is
# written with a large âˆ‘, and or'ing over a list of booleans is written with a
# large or-symbol, âˆ¨.
#
# One major advantage of Â´ is that it allows you to fold any binary function,
# whereas the Mathematical operations are special cases.

{ ğ•¤ â‹„ âˆ = +Â´ 1â€¿2â€¿3â€¿4â€¿5 } ts._Test "Summing a list"
{ ğ•¤ â‹„ âˆ = Ã—Â´ 1â€¿2â€¿3â€¿4â€¿5 } ts._Test "Multiplying over a list"
{ ğ•¤ â‹„ âˆ = -Â´ 1â€¿2â€¿3â€¿4â€¿5 } ts._Test "Alternating series"


ts.Report @
