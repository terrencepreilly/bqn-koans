# Copyright 2022 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.

âŸ¨TestSuiteâŸ© â† â€¢Import "../test.bqn"

ts â† TestSuite "Blocks"

# Blocks are sections of code surrounded by {}. Blocks are a means of explicit
# programming. (That is, non-tacit, or non-point-free programming.)  What a
# block represents depends, in part, on whether that block contains the special
# characters ğ•©, ğ•, ğ•¨, ğ•, ğ•—, ğ”½, ğ•˜, ğ”¾, ğ•£, ğ•¤ and ğ•Š.  Blocks can be used to introduce
# scope, define objects, and create functions.
#
# A block which contains none of the above special characters is an "immediate
# block", and is evaluated immediately. This can be used, among other things,
# to introduce a new lexical scope. This means that variables defined within
# the block are not accessible outside of the block.

{ ğ•¤ â‹„
  a â† "Out of the block"
  {
    a â† "Inside of the block"
  }
  âˆ â‰¡ a
} ts._Test "One level of blocks"

{ ğ•¤ â‹„
  a â† "Outermost block"
  {
    a â† "Outer block"
    {
      a â† "Inner block"
      {
        a â† "Innermost block"
      }
    }
  }
  âˆ â‰¡ a
} ts._Test "Four levels of blocks"


# A block can access its surrounding scope; variables which are not defined
# within a block will resolve to the nearest surrounding scope. You can't use
# â† to update a variable in an outer scope; â† will define a new variable in
# this scope. To update a variable in a surrounding scope, you must make use
# of the â†© operator, which updates an existing variable.

{ ğ•¤ â‹„
  a â† "Outside"
  {
    a â†© "Inside"
  }
  âˆ â‰¡ a
} ts._Test "Outside inside"


# This can be useful for updating a variable without cluttering the outer scope.
# Ï€ here is pi, or approximately 3.14159265358.

{ ğ•¤ â‹„
  radius â† 1 Ã· Ï€
  height â† 2
  cylinder_surface_area â† 0
  {
    circle_surface_area â† Ï€ Ã— radius â‹† 2
    circle_circumference â† 2 Ã— Ï€ Ã— radius
    rect_surface_area â† circle_circumference Ã— height
    cylinder_surface_area â†© rect_surface_area + 2 Ã— circle_surface_area
  }
  expected â† âˆ
  expected = cylinder_surface_area
} ts._Test "Keeping things clean"

{ ğ•¤ â‹„
  seq â† 0
  {
      nums â† 4â€¿âˆ˜ â¥Š âŸ¨
        1, 0, 0, 0
        2, 3, 0, 0
        4, 5, 6, 0
        7, 8, 9, 10
      âŸ©
      seq â†© +Ë nums
  }
  âˆ â‰¡ seq
} ts._Test "Building a sequence"


# To define a function using a block, you can simply use the special name, ğ•©.
# ğ•© represents the right-hand argument. If the block contains at least one ğ•©, then
# it describes a monadic function. Statements in the block are separated by
# any of the list separators. The last statement in the block is the return
# value.

{ ğ•¤ â‹„ âˆ = {- ğ•©} 1 } ts._Test "Simple block"

{ ğ•¤ â‹„ âˆ = {ğ•© + ğ•©} 1 } ts._Test "Addition block"

{ ğ•¤ â‹„
  âˆ = { a â† ğ•© â‹† 2 , 3 + a } 2
} ts._Test "Multiple statements with comma separator"

{ ğ•¤ â‹„
  âˆ = { a â† ğ•© â‹† 3 â‹„ a - 4 } 2
} ts._Test "Multiple statements with diamond separator"

{ ğ•¤ â‹„
  âˆ = {
    a â† ğ•©
    - a
  } 2
} ts._Test "Multiple statements with newline separator"

{ ğ•¤ â‹„
  a â† 0
  {
    a â†© a + ğ•©
  } 5
  âˆ = a
} ts._Test "Redefining in a scope"


# Like other function definitions, blocks can be assigned to a variable.

{ ğ•¤ â‹„
  NegateOverLengthExplicit â† { ğ•© }
  NegateOverLength â† -â—‹â‰ 
  (NegateOverLength â‰¡ NegateOverLengthExplicit) 1â€¿2â€¿3â€¿4
} ts._Test "Negating over"

{ ğ•¤ â‹„
  Double â† { ğ•© Ã— 2 }
  âˆâ€¿âˆâ€¿âˆ â‰¡ Double 7â€¿0.5â€¿Â¯2
} ts._Test "Assigning a block"

{ ğ•¤ â‹„
  count â† 0
  Inc â† { count â†© count + ğ•© }
  Inc 1
  Inc 1
  Inc 1
  âˆ = count
} ts._Test "Maintaining a counter."


# â†© has a special syntax for updates where the new value references the
# existing value: ğ•© ğ”½â†© ğ•¨ is equivalent to ğ•© â†© ğ•© ğ•— ğ•¨.

{ ğ•¤ â‹„
  count â† 1
  Acc â† { count â†© ğ•© }  # Hint: Update this function.
  Acc 2
  Acc 2
  Acc 2
  8 = count
} ts._Test "Maintaining a counter with â†©"


# A block which contains ğ•¨ defines a dyadic function, where ğ•¨ refers to
# the left argument.

{ ğ•¤ â‹„
  âˆ = 2 { ğ•¨ Ã— ğ•© } 3
} ts._Test "Simple dyadic function"

{ ğ•¤ â‹„
  Left â† { ğ•© }
  3 (âŠ£ = Left) 1
} ts._Test "Implement left"

{ ğ•¤ â‹„
  âˆ = 2 { ğ•© - ğ•¨ } 3
} ts._Test "Rearranging arguments"

{ ğ•¤ â‹„
  âˆ â‰¡ 2 { ğ•©â€¿ğ•¨â€¿ğ•©â€¿ğ•¨ } 3
} ts._Test "Making a list"

{ ğ•¤ â‹„
  âˆ â‰¡ 4 { ğ•¨ Ã— Ã· ğ•© } 2â€¿4â€¿1
} ts._Test "List arguments"

{ ğ•¤ â‹„
  PairOverLengthExplicit â† { (â‰  ğ•¨) â‹ˆ â‰  ğ•© }
  PairOverLength â† â‹ˆâ—‹â‰ 
  âŸ¨1âŸ© (PairOverLength â‰¢ PairOverLengthExplicit) 1â€¿2â€¿3â€¿4
} ts._Test "Replicating dyadic over"


# The arguments ğ”½ and ğ”¾ are similar to ğ•¨ and ğ•©, in that they refer to the left
# and right arguments, respectively. But ğ”½ and ğ”¾ refer to functions. If a
# block contains ğ”½ (and no ğ”¾), then it defines a 1-modifier. If a block
# contains a ğ”¾, then it defines a 2-modifier.

{ ğ•¤ â‹„
  _Id â† { ğ”½ }
  âˆ = 2 Ã—_Id 3
} ts._Test "Identity modifier"

{ ğ•¤ â‹„
  _Swap â† { ğ•© ğ”½ ğ•¨ }
  âˆ = 2 -_Swap 3
} ts._Test "Swap"

{ ğ•¤ â‹„
  _Twice â† { ğ”½ ğ”½ ğ•© }
  âˆ = -_Twice 1
} ts._Test "Apply twice"

{ ğ•¤ â‹„
  _Both â† { ğ•© ğ”½ ğ•© }
  âˆ = Ã—_Both 2
} ts._Test "Both"

{ ğ•¤ â‹„
  _Atop_ â† { ğ”½ ğ•¨ ğ”¾ ğ•© }
  âˆ = 2 - _Atop_ Ã— 3
} ts._Test "Atop combinator"

{ ğ•¤ â‹„
  _Over_ â† { (ğ”¾ ğ•¨) ğ”½ ğ”¾ ğ•© }
  âˆ = 2 - _Over_ Ã· 4
} ts._Test "Over combinator"


# The remaining special symbols, ğ•¤/ğ•Š and ğ•£ are self-reference symbols,
# and so they allow for recursion.  ğ•¤ and ğ•Š are used in functions, while
# ğ•£ is used in modifiers.
#
# In order to use ğ•¤, ğ•Š or ğ•£ without infinite recursion, we'll need a means
# of control flow.  The 2-modifier â—¶ (Choose), uses the left function as
# an index to choose one of the right functions.

{ ğ•¤ â‹„
  âˆ = 1 0Ë™â—¶+â€¿- 1
} ts._Test "Choosing the first function"

{ ğ•¤ â‹„
  âˆ = 1 1Ë™â—¶+â€¿- 1
} ts._Test "Choosing the second function"

{ ğ•¤ â‹„
  âˆ = 1 <â—¶-â€¿-Ëœ 2
} ts._Test "Making things always positive"

# Now we can use ğ•Š to call the original function with new arguments
# (to recurse) until we reach the base case.

{ ğ•¤ â‹„
  SumTo â† { ğ•¨ {0 = ğ•©}â—¶({ğ•¨ + ğ•©} ğ•Š {ğ•© - 1})â€¿{ğ•¨} ğ•© }
  âˆ = 0 SumTo 3
} ts._Test "Sum from 1 to n - 1"

# Alternatively, we could use the function name itself to perform recursion.
# This can allow keeping most of the definition tacit. However, it won't work
# in a function which is given no name. And if the function name is changed,
# all references to it must also be updated.

{ ğ•¤ â‹„
  # Hint: Replace a function with "Spread" to make this recursive.
  Spread â† (0 = âŠ£)â—¶{ (ğ•¨ - 1) Ã— (ğ•¨ âˆ¾ ğ•©) }â€¿âŠ¢
  1â€¿2â€¿3 â‰¡ 3 Spread âŸ¨âŸ©
} ts._Test "Recurse with explicit self-reference"


ts.Report @
