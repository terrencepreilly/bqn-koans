# Copyright 2022 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.

âŸ¨TestSuiteâŸ© â† â€¢Import "../test.bqn"

ts â† TestSuite "Blocks"

# Blocks are sections of code surrounded by {}. Blocks are a means of explicit
# programming. (That is, non-tacit, or non-point-free programming.)  What a
# block represents depends, in part, on whether that block contains the special
# characters ğ•©, ğ•, ğ•¨, ğ•, ğ•—, ğ”½, ğ•˜, ğ”¾, ğ•£, ğ•¤ and ğ•Š.  Blocks can be used to introduce
# scope, define objects, and create functions.
#
# A block which contains none of the above special characters is an "immediate
# block", and is evaluated immediately. This can be used, among other things,
# to introduce a new lexical scope. This means that variables defined within
# the block are not accessible outside of the block.

{ ğ•¤ â‹„
  a â† "Out of the block"
  {
    a â† "Inside of the block"
  }
  âˆ â‰¡ a
} ts._Test "One level of blocks"

{ ğ•¤ â‹„
  a â† "Outermost block"
  {
    a â† "Outer block"
    {
      a â† "Inner block"
      {
        a â† "Innermost block"
      }
    }
  }
  âˆ â‰¡ a
} ts._Test "Four levels of blocks"


# A block can access its surrounding scope; variables which are not defined
# within a block will resolve to the nearest surrounding scope. You can't use
# â† to update a variable in an outer scope; â† will define a new variable in
# this scope. To update a variable in a surrounding scope, you must make use
# of the â†© operator, which updates an existing variable.

{ ğ•¤ â‹„
  a â† "Outside"
  {
    a â†© "Inside"
  }
  âˆ â‰¡ a
} ts._Test ""


# This can be useful for updating a variable without cluttering the outer scope.
# Ï€ here is pi, or approximately 3.14159265358.

{ ğ•¤ â‹„
  radius â† 1 Ã· Ï€
  height â† 2
  cylinder_surface_area â† 0
  {
    circle_surface_area â† Ï€ Ã— radius â‹† 2
    circle_circumference â† 2 Ã— Ï€ Ã— radius
    rect_surface_area â† circle_circumference Ã— height
    cylinder_surface_area â†© rect_surface_area + 2 Ã— circle_surface_area
  }
  ((2 + âˆ Ã— Ï€) Ã· Ï€) = cylinder_surface_area
} ts._Test "Keeping things clean"


# To define a function using a block, you can simply use the special name, ğ•©.
# ğ•© represents the right-hand argument. If the block contains at least one ğ•©, then
# it describes a monadic function. Statements in the block are separated by
# any of the list separators. The last statement in the block is the return
# value.

{ ğ•¤ â‹„ âˆ = {- ğ•©} 1 } ts._Test "Simple block"

{ ğ•¤ â‹„ âˆ = {ğ•© + ğ•©} 1 } ts._Test "Addition block"

{ ğ•¤ â‹„
  âˆ = { a â† ğ•© â‹† 2 , 3 + a } 2
} ts._Test "Multiple statements with comma separator"

{ ğ•¤ â‹„
  âˆ = { a â† ğ•© â‹† 3 â‹„ a - 4 } 2
} ts._Test "Multiple statements with diamond separator"

{ ğ•¤ â‹„
  âˆ = {
    a â† ğ•©
    - a
  } 2
} ts._Test "Multiple statements with newline separator"


{ ğ•¤ â‹„
  a â† 0
  {
    a â†© a + ğ•©
  } 5
  âˆ = a
} ts._Test "Redefining in a scope"


# Like other function definitions, blocks can be assigned to a variable.

{ ğ•¤ â‹„
  Double â† { ğ•© Ã— 2 }
  âˆâ€¿âˆâ€¿âˆ â‰¡ Double 7â€¿0.5â€¿Â¯2
} ts._Test "Assigning a block"

{ ğ•¤ â‹„
  count â† 0
  Inc â† { count â†© count + ğ•© }
  Inc 1
  Inc 1
  Inc 1
  âˆ = count
} ts._Test "Maintaining a counter."


# â†© has a special syntax for updates where the new value references the
# existing value: ğ•© ğ”½â†© ğ•¨ is equivalent to ğ•© â†© ğ•© ğ•— ğ•¨.

{ ğ•¤ â‹„
  count â† 1
  Inc â† { count â†© ğ•© }  # Hint: Update this function.
  Inc 2
  Inc 2
  Inc 2
  8 = count
} ts._Test "Maintaining a counter with â†©"


# A block which contains ğ•¨ defines a dyadic function, where ğ•¨ refers to
# the left argument.

{ ğ•¤ â‹„
  âˆ = 2 { ğ•¨ Ã— ğ•© } 3
} ts._Test "Simple dyadic function"

{ ğ•¤ â‹„
  âˆ = 2 { ğ•© - ğ•¨ } 3
} ts._Test "Rearranging arguments"

{ ğ•¤ â‹„
  âˆ â‰¡ 2 { ğ•©â€¿ğ•¨â€¿ğ•©â€¿ğ•¨ } 3
} ts._Test "Making a list"

{ ğ•¤ â‹„
  âˆ â‰¡ 4 { ğ•¨ Ã— Ã· ğ•© } 2â€¿4â€¿1
} ts._Test "List arguments"


# The arguments ğ•˜ and ğ•— are similar to ğ•¨ and ğ•©, in that they refer to the left
# and right arguments, respectively. But ğ•— and ğ•˜ refer to functions. If a
# block contains ğ•— (and no ğ•˜), then it defines a 1-modifier. If a block
# contains a ğ•˜, then it defines a 2-modifier.

{ ğ•¤ â‹„
  _Id â† { ğ”½ }
  âˆ = 2 Ã—_Id 3
} ts._Test "Identity modifier"

{ ğ•¤ â‹„
  _Swap â† { ğ•© ğ”½ ğ•¨ }
  âˆ = 2 -_Swap 3
} ts._Test "Swap"

{ ğ•¤ â‹„
  _Twice â† { ğ”½ ğ”½ ğ•© }
  âˆ = -_Twice 1
} ts._Test "Apply twice"

{ ğ•¤ â‹„
  _Both â† { ğ•© ğ”½ ğ•© }
  âˆ = Ã—_Both 2
} ts._Test "Both"

{ ğ•¤ â‹„
  _Atop_ â† { ğ”½ ğ•¨ ğ”¾ ğ•© }
  âˆ = 2 - _Atop_ Ã— 3
} ts._Test "Atop combinator"

{ ğ•¤ â‹„
  _Over_ â† { (ğ”¾ ğ•¨) ğ”½ ğ”¾ ğ•© }
  âˆ = 2 - _Over_ Ã· 4
} ts._Test "Over combinator"


# The remaining special symbols, ğ•¤/ğ•Š and ğ•£ are self-reference symbols,
# and so they allow for recursion.  ğ•¤ and ğ•Š are used in functions, while
# ğ•£ is used in modifiers.
#
# In order to use ğ•¤, ğ•Š or ğ•£ without infinite recursion, we'll need a means
# of control flow.  The 2-modifier â—¶ (Choose), uses the left function as
# an index to choose one of the right functions.

{ ğ•¤ â‹„
  âˆ = 1 0Ë™â—¶+â€¿- 1
} ts._Test "Choosing the first function"

{ ğ•¤ â‹„
  âˆ = 1 1Ë™â—¶+â€¿- 1
} ts._Test "Choosing the second function"

{ ğ•¤ â‹„
  âˆ = 1 <â—¶-â€¿-Ëœ 2
} ts._Test "Making things always positive"

{ ğ•¤ â‹„
  SumTo â† { ğ•¨ {0 = ğ•©}â—¶({ğ•¨ + ğ•©} ğ•Š {ğ•© - 1})â€¿{ğ•¨} ğ•© }
  âˆ = 0 SumTo 3
} ts._Test "Sum from 1 to n - 1"

ts.Report @
